<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f093fb;
            color: white;
        }

        .btn-secondary:hover {
            background: #e86ce0;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(240, 147, 251, 0.4);
        }

        .btn-success {
            background: #4caf50;
            color: white;
        }

        .btn-success:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #da190b;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(244, 67, 54, 0.4);
        }

        .mode-section {
            margin-bottom: 20px;
        }

        .mode-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .grid-container {
            display: inline-block;
            margin: 0 auto;
            display: flex;
            justify-content: center;
        }

        .sudoku-grid {
            display: inline-grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 0;
            border: 3px solid #333;
            background: #333;
        }

        .sudoku-cell {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #999;
            background: white;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        /* 3x3 box borders */
        .sudoku-cell:nth-child(3n) {
            border-right: 3px solid #333;
        }

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container {
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 25px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s, box-shadow 0.2s;
        }
        .btn-primary { background: #667eea; color: #fff; }
        .btn-primary:hover { background: #5568d3; }
        .btn-secondary { background: #f093fb; color: #fff; }
        .btn-secondary:hover { background: #e86ce0; }
        .btn-success { background: #4caf50; color: #fff; }
        .btn-success:hover { background: #388e3c; }
        .btn-danger { background: #f44336; color: #fff; }
        .btn-danger:hover { background: #c62828; }
        .mode-section { margin-bottom: 20px; }
        .mode-title { font-size: 1.2em; font-weight: bold; color: #333; margin-bottom: 10px; text-align: center; }
        .grid-container { display: flex; justify-content: center; }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 0;
            border: 3px solid #333;
            background: #333;
        }
        .sudoku-cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #999;
            background: #fff;
            font-size: 1.2em;
            font-weight: bold;
            position: relative;
        }
        .sudoku-cell:nth-child(3n) { border-right: 3px solid #333; }
        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 3px solid #333; }
        .sudoku-cell.given { background: #e8e8e8; color: #333; }
        .sudoku-cell.error { background: #ffcdd2; color: #c62828; }
        .sudoku-cell input {
            width: 100%; height: 100%; border: none; text-align: center;
            font-size: 1.2em; font-weight: bold; background: transparent;
        }
        .sudoku-cell input:focus { outline: none; }
        .notes {
            position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none;
            font-size: 0.7em; color: #888; text-align: center; line-height: 1.2; z-index: 1;
        }
        .message { text-align: center; margin-top: 15px; font-size: 1em; padding: 10px; border-radius: 5px; display: none; }
        .message.success { background: #c8e6c9; color: #2e7d32; display: block; }
        .message.error { background: #ffcdd2; color: #c62828; display: block; }
        .message.info { background: #bbdefb; color: #1565c0; display: block; }
        .hidden { display: none; }
        .stats { text-align: center; margin-top: 10px; color: #666; font-size: 0.95em; }
        @media (max-width: 600px) {
            .sudoku-cell { width: 30px; height: 30px; font-size: 1em; }
            .container { padding: 10px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ Sudoku</h1>
        <div class="controls">
            <button class="btn-primary" onclick="switchToEditor()">‚úèÔ∏è Editor Mode</button>
            <button class="btn-secondary" onclick="switchToPlay()">üéØ Play Mode</button>
            <button class="btn-secondary" onclick="resetGrid()">üîÑ Reset</button>
            <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Clear All</button>
            <button class="btn-secondary" onclick="exportPuzzle()">üîó Export Puzzle</button>
        </div>
        <!-- Editor Mode -->
        <div id="editorMode" class="mode-section">
            <div class="mode-title">Editor Mode - Set up the puzzle</div>
            <div class="grid-container"><div id="editorGrid" class="sudoku-grid"></div></div>
            <div class="stats">Click cells to enter numbers (1-9), or leave empty for puzzle hints</div>
            <button class="btn-success" onclick="startGame()" style="width: 100%; margin-top: 15px;">Start Game ‚Üí</button>
            <div id="editorMessage" class="message"></div>
            <div style="margin-top:10px; display:flex; gap:8px; justify-content:center;">
                <button class="btn-primary" onclick="copyPuzzleToClipboard()">Copy Puzzle</button>
                <button class="btn-secondary" onclick="loadSample()">Load Sample</button>
            </div>
        </div>
        <!-- Play Mode -->
        <div id="playMode" class="mode-section hidden">
            <div class="mode-title">Play Mode - Solve the puzzle</div>
            <div class="grid-container"><div id="playGrid" class="sudoku-grid"></div></div>
            <div class="stats">
                <span id="filledCount">Filled: 0/81</span> | <span id="errorCount">Errors: 0</span>
            </div>
            <button class="btn-success" onclick="checkSolution()" style="width: 100%; margin-top: 15px;">‚úì Check Solution</button>
            <div id="playMessage" class="message"></div>
            <div style="margin-top:10px; display:flex; gap:8px; justify-content:center;">
                <button class="btn-secondary" id="noteModeBtn" onclick="toggleNoteMode()">üìù Note Mode: Off</button>
            </div>
        </div>
        <div id="show-url"></div>
    </div>
    <script>
    // --- State ---
    let gameState = {
        original: Array(81).fill(0),
        current: Array(81).fill(0),
        solution: Array(81).fill(0),
        notes: Array(81).fill(null).map(() => [])
    };
    let noteMode = false;

    // --- Initialization ---
    window.addEventListener('DOMContentLoaded', () => {
        showEditor();
        createEditorGrid();
        // Load puzzle from URL param if present
        const params = new URLSearchParams(window.location.search);
        const puzzleParam = params.get('puzzle');
        if (puzzleParam) {
            const decoded = decodePuzzleString(puzzleParam);
            if (decoded) {
                gameState.original = decoded.slice();
                document.querySelectorAll('#editorGrid input').forEach((input, i) => {
                    input.value = gameState.original[i] !== 0 ? gameState.original[i] : '';
                });
                showMessage('editorMessage', 'Puzzle loaded from URL parameter.', 'info');
            } else {
                showMessage('editorMessage', 'Invalid puzzle parameter in URL.', 'error');
            }
        }
    });

    // --- UI Mode Switching ---
    function showEditor() {
        document.getElementById('editorMode').classList.remove('hidden');
        document.getElementById('playMode').classList.add('hidden');
    }
    function showPlay() {
        document.getElementById('editorMode').classList.add('hidden');
        document.getElementById('playMode').classList.remove('hidden');
        updateNoteModeBtn();
    }
    function switchToEditor() {
        showEditor();
        createEditorGrid();
        showMessage('editorMessage', '', '');
    }
    function switchToPlay() {
        showPlay();
        createPlayGrid();
        showMessage('playMessage', '', '');
        updateStats();
    }

    // --- Editor Grid ---
    function createEditorGrid() {
        const grid = document.getElementById('editorGrid');
        grid.innerHTML = '';
        for (let i = 0; i < 81; i++) {
            const cell = document.createElement('div');
            cell.className = 'sudoku-cell';
            cell.id = `editor-${i}`;
            const input = document.createElement('input');
            input.type = 'text';
            input.maxLength = '1';
            input.inputMode = 'numeric';
            input.placeholder = '';
            input.value = gameState.original[i] !== 0 ? gameState.original[i] : '';
            input.addEventListener('input', (e) => {
                const value = e.target.value;
                if (value && (isNaN(value) || value < '1' || value > '9')) {
                    e.target.value = '';
                    return;
                }
                gameState.original[i] = value ? parseInt(value) : 0;
            });
            cell.appendChild(input);
            grid.appendChild(cell);
        }
    }

    // --- Play Grid ---
    function createPlayGrid() {
        const grid = document.getElementById('playGrid');
        grid.innerHTML = '';
        for (let i = 0; i < 81; i++) {
            const cell = document.createElement('div');
            cell.className = 'sudoku-cell';
            cell.id = `play-${i}`;
            if (gameState.original[i] !== 0) {
                cell.classList.add('given');
                cell.textContent = gameState.original[i];
            } else {
                // Show notes visually
                const notesDiv = document.createElement('div');
                notesDiv.className = 'notes';
                if (gameState.notes[i] && gameState.notes[i].length > 0) {
                    notesDiv.textContent = gameState.notes[i].join(' ');
                }
                cell.appendChild(notesDiv);
                // Main input for value (always present)
                const input = document.createElement('input');
                input.type = 'text';
                input.maxLength = '1';
                input.inputMode = 'numeric';
                input.placeholder = '';
                if (!noteMode) {
                    input.value = gameState.current[i] ? gameState.current[i] : '';
                    input.style.fontSize = '1.2em';
                    input.style.color = '#222';
                } else {
                    // In note mode, always show the answer if present
                    if (gameState.current[i]) {
                        input.value = gameState.current[i];
                        input.style.fontSize = '1.2em';
                        input.style.color = '#222';
                        input.disabled = true;
                    } else {
                        input.value = '';
                        input.style.fontSize = '0.7em';
                        input.style.color = '#888';
                        input.disabled = false;
                    }
                }
                input.addEventListener('input', (e) => {
                    if (noteMode) {
                        // Only allow notes in empty cells
                        if (gameState.current[i]) {
                            e.target.value = '';
                            return;
                        }
                        let val = e.target.value.replace(/[^1-9]/g, '');
                        if (val.length === 1) {
                            let n = val;
                            let arr = gameState.notes[i] ? [...gameState.notes[i]] : [];
                            if (arr.includes(n)) {
                                // Remove note
                                arr = arr.filter(x => x !== n);
                            } else {
                                // Add note
                                arr.push(n);
                            }
                            arr = arr.sort((a, b) => a - b);
                            gameState.notes[i] = arr;
                            notesDiv.textContent = arr.join(' ');
                        }
                        e.target.value = '';
                        // Do not touch gameState.current
                    } else {
                        const value = e.target.value;
                        if (value && (isNaN(value) || value < '1' || value > '9')) {
                            e.target.value = '';
                            return;
                        }
                        // When entering an answer, clear notes
                        gameState.current[i] = value ? parseInt(value) : 0;
                        if (value) {
                            gameState.notes[i] = [];
                            notesDiv.textContent = '';
                        }
                        updateStats();
                        validateCell(i);
                    }
                });
                cell.appendChild(input);
            }
            grid.appendChild(cell);
        }
    }

    // --- Game Actions ---
    function startGame() {
        // Copy original to current
        gameState.current = [...gameState.original];
        gameState.notes = Array(81).fill(null).map(() => []);
        // Validate puzzle has at least one empty cell
        const emptyCount = gameState.original.filter(val => val === 0).length;
        if (emptyCount === 0) {
            showMessage('editorMessage', 'Please leave at least one cell empty for the puzzle!', 'error');
            return;
        }
        // Generate a valid solution
        gameState.solution = solveSudoku([...gameState.original]);
        if (!gameState.solution) {
            showMessage('editorMessage', 'Invalid puzzle! Please check your numbers.', 'error');
            return;
        }
        showPlay();
        createPlayGrid();
        showMessage('playMessage', 'Good luck! Solve the puzzle.', 'info');
        updateStats();
    }
    function resetGrid() {
        if (!document.getElementById('playMode').classList.contains('hidden')) {
            gameState.current = [...gameState.original];
            gameState.notes = Array(81).fill(null).map(() => []);
            createPlayGrid();
            updateStats();
            showMessage('playMessage', 'Grid reset to original state.', 'info');
        } else {
            gameState.original = Array(81).fill(0);
            createEditorGrid();
            showMessage('editorMessage', 'Grid cleared!', 'info');
        }
    }
    function clearAll() {
        if (confirm('Are you sure you want to clear everything?')) {
            gameState.original = Array(81).fill(0);
            gameState.current = Array(81).fill(0);
            gameState.solution = Array(81).fill(0);
            gameState.notes = Array(81).fill(null).map(() => []);
            showEditor();
            createEditorGrid();
            showMessage('editorMessage', 'Everything cleared!', 'info');
        }
    }
    function loadSample() {
        gameState.notes = Array(81).fill(null).map(() => []);
        const sample = [
            5,3,0,0,7,0,0,0,0,
            6,0,0,1,9,5,0,0,0,
            0,9,8,0,0,0,0,6,0,
            8,0,0,0,6,0,0,0,3,
            4,0,0,8,0,3,0,0,1,
            7,0,0,0,2,0,0,0,6,
            0,6,0,0,0,0,2,8,0,
            0,0,0,4,1,9,0,0,5,
            0,0,0,0,8,0,0,7,9
        ];
        gameState.original = sample.slice();
        createEditorGrid();
        showMessage('editorMessage', 'Sample puzzle loaded.', 'info');
    }

    // --- Note Mode ---
    function toggleNoteMode() {
        noteMode = !noteMode;
        updateNoteModeBtn();
        createPlayGrid();
    }
    function updateNoteModeBtn() {
        const btn = document.getElementById('noteModeBtn');
        if (btn) btn.textContent = noteMode ? 'üìù Note Mode: On' : 'üìù Note Mode: Off';
    }

    // --- Export/Import ---
    function encodePuzzleString(arr) {
        return arr.map(n => (n || 0).toString(16)).join('');
    }
    function decodePuzzleString(str) {
        if (!str || str.length !== 81) return null;
        const arr = [];
        for (let i = 0; i < 81; i++) {
            const ch = str[i];
            const n = parseInt(ch, 16);
            if (isNaN(n) || n < 0 || n > 15) return null;
            if (n > 9) return null;
            arr.push(n);
        }
        return arr;
    }
    function exportPuzzle() {
        const arr = [];
        document.querySelectorAll('#editorGrid input').forEach((input, i) => {
            const v = input.value;
            arr[i] = v ? parseInt(v) : 0;
        });
        const code = encodePuzzleString(arr);
        const url = `${location.origin}${location.pathname}?puzzle=${encodeURIComponent(code)}`;
        document.getElementById('show-url').innerHTML = `<p style="word-break:break-all; text-align:center; margin-top:15px;">Shareable Puzzle URL: <a href="${url}" target="_blank">${url}</a></p>`;
    }
    async function copyPuzzleToClipboard() {
        const arr = [];
        document.querySelectorAll('#editorGrid input').forEach((input, i) => {
            const v = input.value;
            arr[i] = v ? parseInt(v) : 0;
        });
        const code = encodePuzzleString(arr);
        const url = `${location.origin}${location.pathname}?puzzle=${encodeURIComponent(code)}`;
        try {
            await navigator.clipboard.writeText(url);
            showMessage('editorMessage', 'Puzzle URL copied to clipboard.', 'success');
        } catch (e) {
            showMessage('editorMessage', 'Unable to copy to clipboard. Here is the URL: ' + url, 'info');
        }
    }

    // --- Game Logic ---
    function validateCell(index) {
        const cell = document.getElementById(`play-${index}`);
        const value = gameState.current[index];
        cell.classList.remove('error');
        if (value === 0) return;
        const row = Math.floor(index / 9);
        const col = index % 9;
        for (let i = 0; i < 9; i++) {
            if (i !== col && gameState.current[row * 9 + i] === value) {
                cell.classList.add('error'); return;
            }
        }
        for (let i = 0; i < 9; i++) {
            if (i !== row && gameState.current[i * 9 + col] === value) {
                cell.classList.add('error'); return;
            }
        }
        const boxRow = Math.floor(row / 3) * 3;
        const boxCol = Math.floor(col / 3) * 3;
        for (let i = boxRow; i < boxRow + 3; i++) {
            for (let j = boxCol; j < boxCol + 3; j++) {
                const idx = i * 9 + j;
                if (idx !== index && gameState.current[idx] === value) {
                    cell.classList.add('error'); return;
                }
            }
        }
    }
    function checkSolution() {
        const filledCount = gameState.current.filter(val => val !== 0).length;
        if (filledCount < 81) {
            showMessage('playMessage', 'Please fill all cells!', 'error');
            return;
        }
        let isCorrect = true;
        for (let i = 0; i < 81; i++) {
            if (gameState.current[i] !== gameState.solution[i]) {
                isCorrect = false;
                const cell = document.getElementById(`play-${i}`);
                if (gameState.original[i] === 0) cell.classList.add('error');
            }
        }
        if (isCorrect) {
            showMessage('playMessage', 'üéâ Congratulations! You solved the puzzle!', 'success');
            document.querySelectorAll('#playGrid input').forEach(input => input.disabled = true);
        } else {
            showMessage('playMessage', '‚ùå Some cells are incorrect. Keep trying!', 'error');
        }
    }
    function updateStats() {
        const filledCount = gameState.current.filter(val => val !== 0).length;
        document.getElementById('filledCount').textContent = `Filled: ${filledCount}/81`;
        let errorCount = 0;
        document.querySelectorAll('#playGrid .sudoku-cell.error').forEach(() => errorCount++);
        document.getElementById('errorCount').textContent = `Errors: ${errorCount}`;
    }
    function showMessage(elementId, message, type) {
        const messageEl = document.getElementById(elementId);
        messageEl.textContent = message;
        messageEl.className = `message ${type}`;
    }
    // --- Sudoku Solver ---
    function solveSudoku(grid) {
        const solution = grid.map(x => x);
        function isValid(num, pos) {
            const row = Math.floor(pos / 9);
            const col = pos % 9;
            for (let i = 0; i < 9; i++) if (solution[row * 9 + i] === num) return false;
            for (let i = 0; i < 9; i++) if (solution[i * 9 + col] === num) return false;
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let i = boxRow; i < boxRow + 3; i++) {
                for (let j = boxCol; j < boxCol + 3; j++) {
                    if (solution[i * 9 + j] === num) return false;
                }
            }
            return true;
        }
        function solve() {
            for (let i = 0; i < 81; i++) {
                if (solution[i] === 0) {
                    for (let num = 1; num <= 9; num++) {
                        if (isValid(num, i)) {
                            solution[i] = num;
                            if (solve()) return true;
                            solution[i] = 0;
                        }
                    }
                    return false;
                }
            }
            return true;
        }
        if (solve()) return solution;
        return null;
    }
    </script>
</body>
</html>


